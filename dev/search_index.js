var documenterSearchIndex = {"docs":
[{"location":"api/#Reference-API","page":"Reference API","title":"Reference API","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Documentation for MULTISPATI.jl's public interface.","category":"page"},{"location":"api/#Index","page":"Reference API","title":"Index","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#API","page":"Reference API","title":"API","text":"","category":"section"},{"location":"api/#MULTISPATI","page":"Reference API","title":"MULTISPATI","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"AbstractMultispati\nMultispati\nfit(::Type{Multispati},\n    X::AbstractMatrix{T},\n    W::AbstractMatrix{U},\n    Q::AbstractMatrix{T}=I,\n    D::AbstractMatrix{T}=I / size(X, 2);\n    kwargs\n) where {T<:Real,U<:Real}\npredict(::Multispati, x::AbstractVecOrMat{T}) where {T<:Real}\nreconstruct(::Multispati, y::AbstractVecOrMat{T}) where {T<:Real}\nmoransIbounds\nsize(::AbstractMultispati)\nprojection(::AbstractMultispati)\neigvecs(::AbstractMultispati)\neigvals(::AbstractMultispati)","category":"page"},{"location":"api/#MULTISPATI.AbstractMultispati","page":"Reference API","title":"MULTISPATI.AbstractMultispati","text":"AbstractMultispati\n\n\n\n\n\n","category":"type"},{"location":"api/#MULTISPATI.Multispati","page":"Reference API","title":"MULTISPATI.Multispati","text":"Multispati <: AbstractMultispati\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.fit-Union{Tuple{U}, Tuple{T}, Tuple{Type{Multispati}, AbstractMatrix{T}, AbstractMatrix{U}}, Tuple{Type{Multispati}, AbstractMatrix{T}, AbstractMatrix{U}, AbstractMatrix{T}}, Tuple{Type{Multispati}, AbstractMatrix{T}, AbstractMatrix{U}, AbstractMatrix{T}, AbstractMatrix{T}}} where {T<:Real, U<:Real}","page":"Reference API","title":"StatsAPI.fit","text":"fit(Multispati, X, W, Q=I, D=I / size(X, 2); ...)\n\nPerform Multispati over the data given a matrix X. Each column of X is an observation. W is a connectivity matrix where w_ij is the connection from j -> i. Q is a symmetric matrix of size n (or LinearAlgebra.UniformScaling(@ref))  and D a symmetric matrix of size d (or LinearAlgebra.UniformScaling(@ref)) \n\nKeyword arguments\n\nmaxoutdim: The output dimension, i.e. dimension of the transformed space (min(d, nc-1))\nsolver: The choice of solver:\n:eig: uses LinearAlgebra.eigen (default)\n:eigs: uses Arpack.eigs (always used for sparse data)\ntol: Convergence tolerance for eigs solver (default 0.0)\nmaxiter: Maximum number of iterations for eigs solver (default 300)\n\nReferences\n\nS. Dray, et al. \"Spatial ordination of vegetation data using a generalization of Wartenberg's  multivariate spatial correlation.\" Journal of vegetation science (2008)\n\nde la Cruz and Holmes. \"The duality diagram in data analysis: Examples of modern applications.\"  The annals of applied statistics (2011)\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Union{Tuple{T}, Tuple{Multispati, AbstractVecOrMat{T}}} where T<:Real","page":"Reference API","title":"StatsAPI.predict","text":"predict(M::Multispati, x::AbstractVecOrMat{<:Real})\n\nTransform the observations x with the Multispati model M.\n\nHere, x can be either a vector of length d or a matrix where each column is an observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultivariateStats.reconstruct-Union{Tuple{T}, Tuple{Multispati, AbstractVecOrMat{T}}} where T<:Real","page":"Reference API","title":"MultivariateStats.reconstruct","text":"reconstruct(M::Multispati, y::AbstractVecOrMat{<:Real})\n\nApproximately reconstruct the observations y to the original space using the Multispati model M.\n\nHere, y can be either a vector of length p or a matrix where each column gives the components for an observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MULTISPATI.moransIbounds","page":"Reference API","title":"MULTISPATI.moransIbounds","text":"moransIbounds(M::AbstractMultispati; sparse_approx::Bool=true)\n\nReturn the bounds and expected value for Moran's I given the model M in the order  I_min, I_max, I_0 \n\n\n\n\n\n","category":"function"},{"location":"api/#Base.size-Tuple{AbstractMultispati}","page":"Reference API","title":"Base.size","text":"size(M)\n\nReturns a tuple with the dimensions of input (the dimension of the observation space) and output (the dimension of the principal subspace).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultivariateStats.projection-Tuple{AbstractMultispati}","page":"Reference API","title":"MultivariateStats.projection","text":"projection(M::AbstractMultispati)\n\nReturns the projection matrix (of size (d, p)). Each column of the projection matrix corresponds to a eigenvector. The eigenvectors are arranged in ascending order of the eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.eigvecs-Tuple{AbstractMultispati}","page":"Reference API","title":"LinearAlgebra.eigvecs","text":"eigvecs(M::AbstractMultispati)\n\nGet the eigenvectors of the Multispati model M.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.eigvals-Tuple{AbstractMultispati}","page":"Reference API","title":"LinearAlgebra.eigvals","text":"eigvals(M::AbstractMultispati)\n\nGet the eigenvalues of the Multispati model M.\n\n\n\n\n\n","category":"method"},{"location":"api/#spatialPCA","page":"Reference API","title":"spatialPCA","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"SpatialPCA\nfit(::Type{SpatialPCA},\n    X::AbstractMatrix{T},\n    W::AbstractMatrix{U};\n    kwargs\n) where {T<:Real,U<:Real}\npredict(::SpatialPCA, x::AbstractVecOrMat{T}) where {T<:Real}\nreconstruct(::SpatialPCA, y::AbstractVecOrMat{T}) where {T<:Real}\nvarianceMoransIdecomposition\nmean(::SpatialPCA)","category":"page"},{"location":"api/#MULTISPATI.SpatialPCA","page":"Reference API","title":"MULTISPATI.SpatialPCA","text":"SpatialPCA <: AbstractMultispati\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsAPI.fit-Union{Tuple{U}, Tuple{T}, Tuple{Type{SpatialPCA}, AbstractMatrix{T}, AbstractMatrix{U}}} where {T<:Real, U<:Real}","page":"Reference API","title":"StatsAPI.fit","text":"fit(SpatialPCA, X, W; ...)\n\nPerform spatialPCA over the data given a matrix X and W. Each column of X is an observation.  W is a connectivity matrix where w_ij is the connection from j -> i.\n\nKeyword arguments\n\nmaxoutdim: The output dimension, i.e. dimension of the transformed space (min(d, nc-1))\nsolver: The choice of solver:\n:eig: uses LinearAlgebra.eigen (default)\n:eigs: uses Arpack.eigs (always used for sparse data)\ntol: Convergence tolerance for eigs solver (default 0.0)\nmaxiter: Maximum number of iterations for eigs solver (default 300)\ncenter_sparse: Center sparse matrix X (dense X will always be centered) (default false)\n\nReferences\n\nT. Jombart, et al. \"Revealing cryptic spatial patterns in genetic variability by a new multivariate method.\" Heredity (2008)\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Union{Tuple{T}, Tuple{SpatialPCA, AbstractVecOrMat{T}}} where T<:Real","page":"Reference API","title":"StatsAPI.predict","text":"predict(M::SpatialPCA, x::AbstractVecOrMat{<:Real})\n\nTransform the observations x with the SpatialPCA model M.\n\nHere, x can be either a vector of length d or a matrix where each column is an observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultivariateStats.reconstruct-Union{Tuple{T}, Tuple{SpatialPCA, AbstractVecOrMat{T}}} where T<:Real","page":"Reference API","title":"MultivariateStats.reconstruct","text":"reconstruct(M::SpatialPCA, y::AbstractVecOrMat{<:Real})\n\nApproximately reconstruct the observations y to the original space using the SpatialPCA model M.\n\nHere, y can be either a vector of length p or a matrix where each column gives the components for an observation.\n\n\n\n\n\n","category":"method"},{"location":"api/#MULTISPATI.varianceMoransIdecomposition","page":"Reference API","title":"MULTISPATI.varianceMoransIdecomposition","text":"varianceMoransIdecomposition(M::SpatialPCA, X)\n\nDecompose the eigenvalues into a variance and Moran's I contribution given the model M  and matrix X which was used for fitting the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics.mean-Tuple{SpatialPCA}","page":"Reference API","title":"Statistics.mean","text":"mean(M::SpatialPCA)\n\nReturns the mean vector (of length d).\n\n\n\n\n\n","category":"method"},{"location":"#MULTISPATI.jl","page":"Home","title":"MULTISPATI.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia implementation of MULTISPATI","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MULTISPATI","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, alternatively, via the Pkg API:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MULTISPATI\")","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"api.md\",\n]\nDepth = 3","category":"page"}]
}
